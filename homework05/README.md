Homework 05
===========

### Activity 1: Hulk Smash

**1.** Describe how you implemented the `hulk.py` script.

To implement the `hulk.py` script, I first wrote the `md5sum` and 
`permutations` functions to generate all the candidate password combinations
and their corresponding MD5 hashes.  The `md5sum` function simply uses the
`hashlib` library to generate the checksums.  The `permutations` function
generates all the strings of length `LENGTH` by cycling through every letter
in the user-defined alphabet and recursively calling 
`permutations(LENGTH-1)` to generate all possible strings of length 
`LENGTH-1` and adding the first letter to all these permutations.  The base
case for this function is when length = 1, as this will be the last letter
of any permutation.

I filtered the candidates to only contain valid passwords in the `smash` 
function using a list comprehension.  I returned every `prefix + password`
for every `password` generated by `permutations(length, alphabet)` on the
condition that the `md5sum(prefix + password)` is in the `hashes` set.

To process on multiple cores, I used the multiprocessing library to declare
the `Pool` of cores and then used the `functools` and `itertools` libraries
to divide up the `smash` function and process it on the multiple cores. 
I used `functools.partial` to create the `subsmash` function that takes only 
the `prefix` as an argument and only runs for permutations of length 3.  
This allowed me to divide up the partial functions among the cores, passing
all the permutations of length `LENGTH - 3` as prefixes to the partial
functions and running those partial functions in parallel.

To verify the code works properly, I tested each function individually, 
making sure I get the proper MD5 checksum for a given input, the permutations
function returns all the permutations for the given length and alphabet, and
that smash works given that `md5sum` and `permutations` work and the set of
hashes provided by the instructor.  I then tested the script in full with 
multiprocessing and inputting various lengths, alphabets, prefixes, and 
cores.  The script behaved as expected in each test case.

**2.**
| Processes |     Time     |
|:---------:|:------------:|
|     1     | 203m 24.260s |
|     2     |  36m 33.450s |
|     4     |  20m 32.932s |
|     8     |  17m 19.632s |
|     16    |  17m 30.582s |
(Note: The 2 to 16 process executions were run on computers in Cushing 303
while the 1 process execution was run on student03.)

Looking at this table, it is clear that, generally, the more processes that 
are utilized to run this script, the more quickly it is run.  However the
time is fairly similar between 8 and 16 processes, suggesting that at a 
certain point, adding more cores to a particular solution may not make it 
any faster due to overhead, or that I ran into trouble by specifying more 
cores in the script than are available on the machine.  2 processes was 
significantly faster than 1, but I do not know if this is a valid comparison
considering the 1 process execution was run on a different machine than all
the others.

**3.** What would make a password more difficult to brute-force: more
complex alphabet or longer password?

Based on this project and my discrete math knowledge, a longer password is
better than a more complex alphabet at making a password more difficult to
brute-force.  This is because brute forcing a password of length l with 
an alphabet of a characters requires generating a^l strings.  This means that
given a sufficiently complex alphabet, increasing the length of the password
requires generating many more passwords than increasing the number of 
characters.  I saw this in my testing as well, as increasing the length 
input of the script increased the computation time significantly each time.

### Activity 2: Inverted Index

**1.** How does the `iv_map.py` script work?

The `iv_map` script keeps track of line numbers by looping through and
enumerating each line and then looping through each word in that line,
removing undesirable characters from that word, and then printing out that
word alongside the line number produced by the `enumerate`  command.

To remove the undesirable characters I created a string `punct` from 
`string.punctuation` and from which I removed the '-' character using 
`re.sub` to replace '-' with '' and to which I added the utf-8 punctuation
present in the test string but not included in `string.punctuation`.  I then
used the `translate` method of string to replace all the characters in 
`punct` with nothing.

**2.** How does the `iv_reduce.py` script work?

The `iv_reduce.py` script aggregates the results for each word by first 
storing each line in the input in a `set`.  This removes duplicate items from
the input.  The script then creates a `dict` in which to store the words and
line numbers `numVals`.  It then increments through the set, and splits each
element of the set up into the word and the line number `k` and `v`.  If that
`k` is a key in the dictionary than it adds a ' ' and `v` (the next line 
number) to that string, otherwise it sets the value for key `k` to `str(v)`.

The script outputs the results in the correct format by first sorting the
numbers in value string for each key word.  To do this, it creates an empty
list `nums` and then adds every `num` in the value using `split`.  It then
converts these numbers back into a sorted string with
`' '.join(sorted(nums,key=int))`.  Finally, the script sorts the dictionary
based on the key (the words) and then ouputs each key, value pair 
separated by a tab.
